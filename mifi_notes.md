# Моя подготовка в МИФИ 2026

2 января, билет 2,3,4 (биты, числа, строки)

Практика кода
float() = вещественное число (число с плавающей точко), пример 340.0 (в питон 64 битное число, а именно double precision, то есть двойная точность)
В float 64 бита делятся на: 1 бит знака, 11 бит экспоненты (размер) и 52 бита мантиссы (сами цифры). Из-за этого возможны микро-ошибки типа 0.1 + 0.2 = 0.3000...4
int() = целое число (integer (целочисленный тип данных)), например 2 (имеет произвольную точность, может быть сколь угодно большим)
str() = строка (string), например "привет"
True/False = двоичный ответ (Boolean (булевое, логический тип данных)), весит 1 бит. True = 1 (правда), False = 0 (ложь)
type() = пишет тип того, что находится в скобках. допустим при 123, получситя class 'int'

Мат теория
перевод 13 в двоичную систему: 13 / 2 = 6 (1), 6 / 2 = 3 (0), 3 / 2 = 1 (1),
1 / 2 = 0 (1), ответ 1101 (ответ записывается в обратном порядке, потому что изначально получаем 3210, то есть начинается с самого крупного, а начинать запись нужно с самого мелкого разряд, то есть с числа под степенью 0)
при переводе 1101 в десятичную систему нужно расставить степени с нуля, 0 1 2 3,
потом подставить их к двойке, потому что система двоичная. 
Получится 2**0 + 2**1 + 2**2 + 2**3 = 13

Теория кода
бит (bit) - самая маленькая ячейка, в ней может быть 0 или 1
байт (bite) - 8 бит
диапазон: а один байт можно записать число от 00000000 до 11111111. В десятичной системе это от 0 до 255.(записать можно 256, потому что 0 тоже учитывается, чтобы учесть 00000000 в самом начале)
Отсчет с 0 нужен для правильной работы степеней (2^0=1, иначе пришлось бы пропускать) и быстрой адресации памяти
И = and (конъюнкция, логическое умножение, допустим если есть хотя бы один false, то все выражение будет false)
ИЛИ = or (дихъюнкция, логическое сложение, если будет false и true, то будет true)
НЕ (NOT / Инверсия): Переворачивает значение (из True делает False и наоборот)

Команды к гитхабу
git add . 
(все подготовить к отправке, точка обязательна)
git commit -m "feat: добавил ввод данных и конспект по теории" 
(отправить комментарий, он в ковычках)
git push --set-upstream origin main (установить связь, если есть фатальная ошибка)
git push (отправить на гитхаб)


3 января, билет 5 (ветвление)

Практика кода
if a == 17
    print("хорошо")
else:
    print("плохо")

Теория кода
условный оператор и логические ветвления, Control Flow (управление потоком)
Структура if - elif - else
Один уровень вложенности = 4 пробела
if <условие>: — проверяется первым.
elif <условие>: — (сокращение от else if) проверяется, только если предыдущие условия были ложны (False). Таких блоков может быть сколько угодно.
else: — «запасной выход». Срабатывает, если ни одно из условий выше не подошло.
Внутри if всегда находится выражение, которое Python превращает в тип bool (True или False).
Сравнения: == (равно)
!= (не равно) >, <, >=, <=
Логические связки: and, or, not.

4 января, билет 7 (списки, циклы)

Практика кода

weight_list = []
weight = 100
for i in range(1, 7):
    weight *= 1.1
    weight_list.append(round(weight, 1))
print(weight_list)

Теория кода
Список — это упорядоченная коллекция элементов. У каждого элемента есть свой индекс. Индексация начинается с нуля.
В список можно добавлять элементы (append) или удалять их.
В одном списке могут лежать и числа, и строки одновременно.

Циклы - повторение одного и того же нужное количество раз.
Цикл while (Пока условие верно)
Используется, когда мы не знаем точно, сколько раз нужно повторить действие.
Цикл for (Для каждого элемента)
Используется, когда у нас есть четкий диапазон или список.

5 января (словари)

Практика кода

#База данных Snake Intelligence
snake_inventory = {
    "udav_001": {
        "name": "Абаддон",
        "weight": 8500,
        "price": 740000
    },
    "caninus_002": {
        "name": "Василиса",
        "weight": 500,
        "price": 0
    }
}

#1. Добавление данных (Ввод)
#Напрямую по ключу (для новых или конкретных объектов)
snake_inventory["python_003"] = {"name": "Каа", "weight": 12000}

#2. Обновление через цикл (Массовый ввод)
#Допустим, мы провели инвентаризацию и всем змеям обновили статус
for snake_id in snake_inventory:
    snake_inventory[snake_id]["last_check"] = "2026-01-05"

#3. Безопасное извлечение
#Если мы не уверены, есть ли у змеи цена, используем .get()
for s_id, s_data in snake_inventory.items():
    price = s_data.get("price", "Оценки нет")
    print(f"Змея {s_data['name']}: {price}")


Теория кода
Словарь (dict) — это неупорядоченная структура данных, работающая по принципу «Ключ: Значение». Называется ассоциативным массивом (доступ к значению по ключу, а не по числовому индексу (ассоциирует ключ с значением)) или хеш-таблицей (принимает любой объект (например, строку), возвращает целое число (хеш))
hash('банан') → 987654321 (скрытый индекс, по которрому сохраняется значение)
Ключи должны быть хешируемыми (неизменяемыми: str, int, tuple)
Нельзя использовать list, dict, set как ключ — они не хешируемы.

Основные свойства
Уникальность ключей: Ключ в словаре должен быть уникальным. Если присвоить значение уже существующему ключу, старое значение будет перезаписано.Типы данных: Ключом может быть только неизменяемый тип (строка, число, кортеж). Значением может быть любой объект Python (список, другой словарь, число, строка).Скорость: Поиск по ключу происходит мгновенно ($O(1)$), в отличие от списков, где нужно перебирать все элементы.

.keys() - Возвращает все ключи - ID всех змей
.values() - Возвращает все значения - Характеристики всех змей
.items() - Возвращает пары (ключ, значение) - Для циклов for key, data
.get(key, default) - Безопасное получение значения - Избегаем ошибки, если цены нет